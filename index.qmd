---
toc: false
css: custom.scss
---

```{ojs}
//| echo: false

d3 = require("d3")
topojson = require("topojson")
```

```{ojs}
//| echo: false

geoswe = fetch("https://raw.githubusercontent.com/jnordgren/swedish_data_map_geojson/refs/heads/master/GeoJSON/swedish_provinces.geojson").then((response) => response.json())
```

::: {.grid}

::: {.g-col-1}

```{ojs}
//| echo: false

map = {
  const chartWidth = 350;
  const chartHeight = 700;
  const backgroundColor = "#EAF2FA";
  const landColor = "#09A573";
  const landStroke = "#FCF5E9";
  const markerColor = "#E26F99";


  const projection = d3.geoMercator()
                      .translate([chartWidth / 3, chartHeight / 3])
                      .fitSize([chartWidth, chartHeight], geoswe);

  const pathGenerator = d3.geoPath(projection);


  const svg = d3.create('svg')
                .attr("title", "Map")
                .attr('width', chartWidth)
                .attr('height', chartHeight)
                .on('dblclick', reset);


  const box = pathGenerator.bounds(geoswe)
  // const box = [
      // [21, 10],
      // [330, 665]]

  console.log(box)


  const path = svg.append('g').
      selectAll('path')
        .data(geoswe.features)
        .join('path')
        .attr('d', pathGenerator)
        .attr('fill', landColor)
        .attr('stroke', landStroke)
        .attr('stroke-width', 1);

  path.style('cursor', 'pointer').on('click', clicked);

  path.append('title').text((d) => d.properties.name);

  function clicked (event, p){
    const t = svg.transition().duration(750)

    path.transition().style('fill', d3.color('gray'));

    d3.select(this).transition().style('fill', 'red');

    car(p.properties.name)

  }

  function reset() {
    car()

    path.transition().style("fill", null);
    svg.transition().duration(750).call(
      // zoom.transform,
      d3.zoomIdentity,
      d3.zoomTransform(svg.node()).invert([chartWidth / 2, chartHeight / 2]));

}

 const circles = svg.append('g').selectAll('circle');

    const conf_data_w_xy = conf_data.map((d) => ({
        name: d.name,
      fx : projection(d.coordinates)[0],
      fy : projection(d.coordinates)[1]
    })).concat(raw_points
    .filter((d) => (d.type == 'project'))
    .map((d) => ({
        name: d.name,
        x : projection(d.coordinates)[0],
        y : projection(d.coordinates)[1],
        type: d.type
    })))

    console.log(conf_data_w_xy)


  // Custom force to put all nodes in a box
  function boxingForce() {
    const radius = 5;

    for (let node of conf_data_w_xy) {
        // Of the positions exceed the box, set them to the boundary position.
        // You may want to include your nodes width to not overlap with the box.

        if (node.x - radius < box[0][0]) {
          node.x = box[0][0] + radius
        } else if (node.x + radius > box[1][0]) {
          console.log(node  )
          node.x = box[1][0] - radius
        }

        if (node.y - radius < box[0][1]) {
          node.y = box[0][1] + radius
        } else if (node.y + radius > box[1][1]) {
          node.y = box[1][1] - radius
        }

    }
}

    const sim = d3.forceSimulation(conf_data_w_xy);
      sim.force('many', d3.forceManyBody().strength(0.25).distanceMax(10))
        .force("collide", d3.forceCollide().radius(5).strength(0.3))
        .force("bounds", boxingForce);

    sim.stop();
    draw();

    console.log(conf_data_w_xy)


    const interval = d3.interval(ticked, 500);

    let ticks = 0;
    const maxTicks = 10000;

    function ticked() {
        if(ticks < maxTicks) {
            sim.tick();
            d3.select("#label").text('Tick: ' + ++ticks + ' of ' + maxTicks);
            redraw();
        } else {
            interval.stop();
        }
    }


  function color(point){
    if(point.type == 'conference'){
      return 'blue'
    } else if (point.type == 'project'){
      return 'red'
    }
  }


    function draw() {
        svg.selectAll("circle")
                .data(conf_data_w_xy)
                .join("circle")
                .attr("r", 5)
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .style("fill", d => color(d))
    }

    function redraw() {
        svg.selectAll("circle")
                .attr("cx", d => d.x)
                .attr("cy", d => d.y)
                .append('title').text((d) => `${d.name} - ${d.y}, ${d.x}`)

    }

  car()
  return svg.node();
}

```


:::

::: {.g-col-3 .listcol}

:::



:::

```{ojs}
//| echo: false

function car (a) {

  const table = d3.selectAll('.g-col-3');

  table.selectAll('div').remove();

  const cardata = a == undefined ? gathered_points : gathered_points.filter((d) => (d.region == a));

  table
  .style('width', '500 px')
  .selectAll('div')
    .data(cardata.filter( (d) => (d.type == "conference")))
    .join('div').html(d => `<h4>${d.name}</h4><h5>${d.town}<span style="float:right;">${d.days} ${d.year}</span></h5>`)
    .data(cardata)
    .enter().insert('div')
    .join('div').html(d => `<h4>${d.name} <span style="float:right;"><a href="${d.url}">visit</a></span></h4><h5> ${d.town}<span style="float:right;">${d.year}-${d.end}</span></h5>`)
}
```


```{ojs}
//| echo: false

yaml = require('js-yaml')
projaml = FileAttachment('./projects.yaml').text()
confyaml = FileAttachment('./conference.yaml').text()

towns = FileAttachment('towns.json').json()

conf_data = yaml.load(confyaml).map((d) => ({
  name : d.title,
  town: d.town,
  coordinates : towns.find((t) => (t.name == d.town)).coordinates,
  region : towns.find((t) => (t.name == d.town)).region,
  type: 'conference',
  year: d.year,
  end: d.end,
  days: d.days

}))
sorted_c = conf_data.sort(d => d.end)

raw_points = [].concat(
conf_data,
yaml.load(projaml).map((d) => ({
  name : d.name,
  town: d.town,
  coordinates : towns.find((t) => (t.name == d.town)).coordinates,
  region : towns.find((t) => (t.name == d.town)).region,
  type: 'project',
  year: d.year,
  end: d.end,
  url: d.url

}))
)

gathered_points = raw_points.sort((d) => (d.end, d.name))

```
